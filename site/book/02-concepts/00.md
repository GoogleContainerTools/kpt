What is kpt?

> kpt is a Git-native, semantic-aware, extensible client-side tool for packaging, customizing,
> validating, and applying Kubernetes resources.

That's a pretty terse description, so let's break it down:

- **Git-native**: kpt uses Git to publish, compose, and update configuration. As a result,
  configuration changes may be reviewed, approved, audited and rolled back using existing Git
  workflows.

- **Semantic-aware**: Configuration used by kpt must conform to the _Kubernetes Resource Model
  (KRM)_ which have a defined schema and semantic. KRM resources — whether core Kubernetes
  resources such as `Deployment` or custom resources defined using a `CRD` — have an OpenAPI
  specification which is used for semantic-aware operations in kpt. For example, when rebasing a
  locally modified package to a new version, the merge operation is more than simply performing a
  text-based file merge, it takes the schema into account.

  In contrast, many configuration tools today interleave data and code, for example by embedding a
  templating language in YAML. As configuration becomes complex (it's a question of _when_ not
  _if_), it becomes hard to read and understand. Furthermore, this prevent external tooling from
  easily consuming such configuration leading to a closed ecosystem.

- **Extensible**: kpt provides a small core machinery and powerful extension mechanisms. There are
  two main extension mechanisms in kpt: a) kpt can gain semantic understanding of arbitrary KRM
  resources by consuming OpenAPI documents. kpt core itself does not hardcode any type-specific
  information. b) kpt can perform arbitrary operations on resources using kpt functions.

- **Packaging**: A package is a bundle of KRM resources representing a useful unit of functionality.

- **Customizing**: Seldom you can take an off-the-shelf package and deploy it without any
  customization. We know from experience working with Kubernetes configuration and with internal
  systems at Google that there is no one-size-fit-all customization technique. Sometimes the most
  appropriate customization is to edit a YAML file directly. Sometimes, you want to automate a
  one-time customization, sometimes you want to repeatedly perform a customization. Sometimes you
  want to use parametrization, sometimes perform bulk search & replace, sometimes you want to use a
  general-purpose programming language. kpt enables all these techniques. In contrast, tools that
  provide just one customization technique (e.g. parameterization) cannot addresses all these
  different use cases well and inevitably lead to anti-patterns (e.g. over-parameterization).

- **Validating**: In the era of fast-paced DevOps, we need to reduce the risk of misconfiguration
  leading to an outage, security vulnerabilities, or non-compliance. Validation goes hand-in-hand
  with customization and kpt functions can be used to automate both mutation and validation of
  resources. Example of validator functions include schema-validation, linting, policy enforcement,
  and security auditing.

- **Applying**: When it comes to deploying a package to a Kubernetes cluster, kpt complements
  `kubectl` by keeping inventory of deployed resources, providing an aggregate view of their status,
  and providing an improved preview experience.

The two fundamental concepts in kpt are packages and functions. Let's define them.
